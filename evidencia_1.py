import streamlit as st
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# -----------------------------------
# CONFIGURACIN


# -*- coding: utf-8 -*-
"""EVIDENCIA 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QLAibjZnUoUI7kp_uLErUzZ3nBLqAK5N
"""

# ==========================================
# CDIGO MAESTRO: PORTAFOLIO + 5 FACTORES + MONTE CARLO
# ==========================================

# 1. INSTALACIN DE LIBRERAS
!pip install yfinance statsmodels --quiet

import pandas as pd
import yfinance as yf
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm
import warnings

# Configuraci贸n visual y supresi贸n de alertas
warnings.simplefilter(action='ignore', category=FutureWarning)
pd.options.display.float_format = '{:.4f}'.format

# ---------------------------------------------------------
# 2. PARMETROS DEL PROYECTO
# ---------------------------------------------------------
# Selecci贸n de 10 empresas diversificadas (Tech, Auto, Finanzas, Energ铆a, Retail, Salud)
my_tickers = ['F', 'VTIP', 'MU', 'BE', 'FSLR', 'SHEL', 'VNQ', 'BABA', 'V', 'MA']

# Proxies para el Modelo de 5 Factores (usando ETFs para evitar bloqueo de servidor)
# 1. Mercado (SPY), 2. Tama帽o (IWM), 3. Valor (VTV),
# 4. Calidad/Profitability (QUAL), 5. Momentum/Inversi贸n (MTUM)
factor_tickers = ['SPY', 'IWM', 'VTV', 'QUAL', 'MTUM']

start_date = '2020-12-01'
end_date = '2023-12-01' # 36 Meses exactos
risk_free_rate_annual = 0.05 # Requisito: 5%

# ---------------------------------------------------------
# 3. DESCARGA Y PROCESAMIENTO DE DATOS
# ---------------------------------------------------------
print("1. Descargando precios de Yahoo Finance (36 meses)...")
all_data = yf.download(my_tickers + factor_tickers, start=start_date, end=end_date, progress=False, auto_adjust=False)

# Asegurar que usamos el precio ajustado de cierre
if 'Adj Close' in all_data.columns:
    prices = all_data['Adj Close']
else:
    prices = all_data['Close']

# Calcular retornos mensuales
monthly_prices = prices.resample('ME').last()
monthly_returns = monthly_prices.pct_change().dropna()

# Tasa libre de riesgo mensual
rf_monthly = (1 + risk_free_rate_annual)**(1/12) - 1

# ---------------------------------------------------------
# 4. CONSTRUCCIN DEL MODELO DE 5 FACTORES
# ---------------------------------------------------------
# Variables Independientes (X): Los 5 Factores - Tasa libre de riesgo
factors_df = pd.DataFrame()
factors_df['Mkt-RF'] = monthly_returns['SPY'] - rf_monthly
factors_df['Small_Cap'] = monthly_returns['IWM'] - rf_monthly
factors_df['Value'] = monthly_returns['VTV'] - rf_monthly
factors_df['Quality'] = monthly_returns['QUAL'] - rf_monthly
factors_df['Momentum'] = monthly_returns['MTUM'] - rf_monthly

X = sm.add_constant(factors_df) # A帽adir constante (Alpha)

results_list = []

print("2. Calculando Modelo de 5 Factores y Rendimientos Esperados...")

for ticker in my_tickers:
    # Variable Dependiente (Y): Retorno del activo - Tasa libre de riesgo
    y = monthly_returns[ticker] - rf_monthly

    # Regresi贸n Lineal M煤ltiple
    model = sm.OLS(y, X).fit()
    betas = model.params

    # Calcular Rendimiento Esperado usando la f贸rmula del modelo de factores
    # E(R) = Rf + Suma(Beta_i * Promedio_Factor_i)
    avg_premiums = factors_df.mean()
    expected_excess = (betas[factors_df.columns] * avg_premiums).sum()

    expected_monthly = rf_monthly + expected_excess
    expected_annual = (1 + expected_monthly)**12 - 1

    results_list.append({
        'Ticker': ticker,
        'Exp. Annual Return (%)': expected_annual * 100,
        'R-Squared': model.rsquared
    })

# Crear DataFrame y ordenar de MAYOR a MENOR
df_results = pd.DataFrame(results_list).sort_values(by='Exp. Annual Return (%)', ascending=False)

print("\nResultados Ordenados (Mayor a Menor Rendimiento Esperado):")
print(df_results[['Ticker', 'Exp. Annual Return (%)', 'R-Squared']])

# ---------------------------------------------------------
# 5. ESTRATEGIA DE PORTAFOLIO (SELECCIN Y ELIMINACIN)
# ---------------------------------------------------------
top_5 = df_results.head(5)
bottom_5 = df_results.tail(5)
best_stock = df_results.iloc[0]['Ticker']

print("\n" + "="*40)
print("DECISIN DE PORTAFOLIO")
print("="*40)
print(f"Empresas MANTENIDAS (Top 5):\n {top_5['Ticker'].tolist()}")
print(f"Empresas ELIMINADAS (Bottom 5 - Menor rendimiento proyectado):\n {bottom_5['Ticker'].tolist()}")
print(f"Empresa ganadora para simulaci贸n: {best_stock}")

# ---------------------------------------------------------
# 6. SIMULACIN MONTE CARLO (30m Train / 6m Test)
# ---------------------------------------------------------
print(f"\n3. Ejecutando Monte Carlo para {best_stock}...")

# Obtener precios diarios solo de la mejor empresa para mayor precisi贸n
stock_daily = yf.download(best_stock, start=start_date, end=end_date, progress=False, auto_adjust=False)
adj_close_daily = stock_daily['Adj Close'] if 'Adj Close' in stock_daily.columns else stock_daily['Close']

# Si devuelve DataFrame, convertir a Series
if isinstance(adj_close_daily, pd.DataFrame):
    adj_close_daily = adj_close_daily.iloc[:, 0]

returns_daily = adj_close_daily.pct_change().dropna()

# DIVISIN: Primeros 30 meses (Entrenamiento) vs ltimos 6 meses (Prueba)
# 30 meses * 21 d铆as h谩biles aprox = 630 d铆as (aproximaci贸n, usaremos corte por fecha)
cutoff_date = pd.to_datetime(start_date) + pd.DateOffset(months=30)
train = returns_daily[:cutoff_date]
test = returns_daily[cutoff_date:]

# Par谩metros Simulaci贸n
mu = train.mean()
sigma = train.std()
S_0 = adj_close_daily.loc[train.index[-1]] # ltimo precio del entrenamiento
T_days = len(test)
N_SIM = 100

# Funci贸n GBM Vectorizada
def simulate_gbm(s_0, mu, sigma, n_sims, steps):
    # Generar choques aleatorios
    dt = 1
    dW = np.random.normal(0, 1, (n_sims, steps))
    # Drift
    drift = (mu - 0.5 * sigma**2) * dt
    # Difusi贸n
    diffusion = sigma * np.sqrt(dt) * dW
    # Trayectorias
    daily_returns_sim = np.exp(drift + diffusion)
    # Acumular precio
    price_paths = np.zeros((n_sims, steps + 1))
    price_paths[:, 0] = s_0
    for t in range(1, steps + 1):
        price_paths[:, t] = price_paths[:, t-1] * daily_returns_sim[:, t-1]
    return price_paths

# Ejecutar
simulations = simulate_gbm(S_0, mu, sigma, N_SIM, T_days)

# ---------------------------------------------------------
# 7. GRFICA DE RUTAS ESTIMADAS
# ---------------------------------------------------------
plt.figure(figsize=(12, 6))

# Fechas para la gr谩fica (eje X)
sim_dates = pd.date_range(start=test.index[0], periods=T_days + 1, freq='B')

# Graficar simulaciones
plt.plot(sim_dates, simulations.T, color='gray', alpha=0.1)
# Graficar media de simulaciones
plt.plot(sim_dates, simulations.mean(axis=0), color='red', linewidth=2, label='Pron贸stico Promedio (Monte Carlo)')
# Graficar datos reales (Test set)
plt.plot(test.index, adj_close_daily.loc[test.index], color='blue', linewidth=2, label='Precio Real (Prueba)')

plt.title(f'Simulaci贸n Monte Carlo: {best_stock} \n(Entrenamiento: 30 meses | Prueba: 6 meses)')
plt.xlabel('Fecha')
plt.ylabel('Precio USD')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()


import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import yfinance as yf  # <--- FALTABA ESTA LNEA

# ----------------------------------------------------
# 1. PARMETROS
# ----------------------------------------------------
tickers_top5 = ['MA', 'V', 'F', 'VNQ', 'MU']
start_date = '2020-12-01'
end_date = '2023-12-01'

# ----------------------------------------------------
# 2. DESCARGA DE DATOS (CORREGIDA)
# ----------------------------------------------------
print("Descargando precios...")
# auto_adjust=False asegura que 'Adj Close' exista
data = yf.download(tickers_top5, start=start_date, end=end_date, progress=False, auto_adjust=False)

# Selecci贸n segura de columna
if 'Adj Close' in data.columns:
    prices = data['Adj Close']
else:
    prices = data['Close']

# ----------------------------------------------------
# 3. CLCULO DE VaR
# ----------------------------------------------------
# Calcular retornos diarios
returns = prices.pct_change().dropna()

# Asignar pesos iguales (1/5 = 20% cada una)
weights = np.array([1/len(tickers_top5)] * len(tickers_top5))

# Retorno diario del portafolio (Producto punto de matrices)
portfolio_returns = returns.dot(weights)

# C谩lculo de VaR con 95% de confianza (Hist贸rico)
VaR_95 = np.percentile(portfolio_returns, 5)  # El valor en el percentil 5% m谩s bajo
VaR_percent = -VaR_95 * 100  # Convertir a positivo para expresarlo como p茅rdida

print(f"\nVaR (95%) Diario del Portafolio: {VaR_percent:.2f}%")
print(f"Interpretaci贸n: Con un 95% de confianza, no perder谩s m谩s del {VaR_percent:.2f}% de tu inversi贸n en un solo d铆a.")

# ----------------------------------------------------
# 4. GRFICA
# ----------------------------------------------------
plt.figure(figsize=(10,6))
plt.hist(portfolio_returns, bins=50, alpha=0.6, color='skyblue', edgecolor='black')
plt.axvline(x=VaR_95, color='red', linestyle='--', linewidth=2, label=f'VaR 95% = {VaR_95:.4f}')
plt.title("Distribuci贸n de Retornos Diarios y Valor en Riesgo (VaR)")
plt.xlabel("Retorno Diario")
plt.ylabel("Frecuencia")
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()





n_assets = len(tickers_top5)
n_portfolios = 10000
rf = 0.05 / 252  # Tasa libre de riesgo diaria

mean_returns = returns.mean()
cov_matrix = returns.cov()

results = np.zeros((3, n_portfolios))  # retornos, volatilidad, Sharpe
weights_record = []

for i in range(n_portfolios):
    weights = np.random.random(n_assets)
    weights /= np.sum(weights)

    ret = np.dot(weights, mean_returns)
    vol = np.sqrt(np.dot(weights.T, np.dot(cov_matrix, weights)))
    sharpe = (ret - rf) / vol

    results[0, i] = ret
    results[1, i] = vol
    results[2, i] = sharpe
    weights_record.append(weights)

# Convertir a DataFrame
results_df = pd.DataFrame(results.T, columns=['Return', 'Volatility', 'Sharpe'])
weights_df = pd.DataFrame(weights_record, columns=tickers_top5)

# Encontrar portafolio 贸ptimo
opt_idx = results_df['Sharpe'].idxmax()
opt_weights = weights_df.iloc[opt_idx]

print("\nPesos 贸ptimos que maximizan el Sharpe Ratio:")
print(opt_weights)

# Gr谩fica Frontera Eficiente
plt.figure(figsize=(10, 6))
plt.scatter(results_df['Volatility'], results_df['Return'], c=results_df['Sharpe'], cmap='viridis', alpha=0.5)
plt.colorbar(label='Sharpe Ratio')
plt.scatter(results_df.loc[opt_idx, 'Volatility'], results_df.loc[opt_idx, 'Return'], c='red', s=50, label='ptimo')
plt.xlabel('Volatilidad (Riesgo)')
plt.ylabel('Retorno Esperado')
plt.title('Frontera Eficiente - Simulaci贸n Monte Carlo')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()







!pip install streamlit yfinance matplotlib seaborn --quiet
import streamlit as st
import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# --- 1. CONFIGURACIN DE LA PGINA ---
st.set_page_config(page_title="Dashboard de Inversi贸n", layout="wide")

# --- 2. PARMETROS ---
tickers = ['MA', 'V', 'F', 'VNQ', 'MU']
vix = '^VIX'
start = '2020-12-01'
end = '2023-12-01'

# --- 3. DESCARGA DE DATOS (CORREGIDA) ---
# Usamos cache para que no descargue todo cada vez que tocas un bot贸n
@st.cache_data
def load_data():
    # Descargar todo junto. auto_adjust=False asegura que exista 'Adj Close'
    df = yf.download(tickers + [vix], start=start, end=end, auto_adjust=False)

    # Manejo seguro de columnas (Adj Close vs Close)
    if 'Adj Close' in df.columns:
        data = df['Adj Close']
    else:
        data = df['Close']
    return data

try:
    data = load_data()
except Exception as e:
    st.error(f"Error al descargar datos: {e}")
    st.stop()

# --- 4. CLCULOS ---
# Separamos las acciones del VIX para calcular retornos del portafolio
stock_data = data[tickers]
returns = stock_data.pct_change().dropna()

# Retorno acumulado promedio (equi-ponderado)
portfolio_ret = returns.mean(axis=1).cumsum()

# --- 5. DASHBOARD INTERFAZ ---
st.title(" Dashboard Interactivo del Portafolio")
st.markdown("An谩lisis de acciones financieras, tecnol贸gicas y bienes ra铆ces.")

# Layout de columnas para m茅tricas
col1, col2 = st.columns(2)

with col1:
    st.subheader(" Retorno acumulado del portafolio")
    st.line_chart(portfolio_ret)

with col2:
    st.subheader(" Precios de cierre m谩s recientes")
    # Mostramos los 煤ltimos precios disponibles
    latest_prices = stock_data.iloc[-1]
    st.dataframe(latest_prices.to_frame("Precio USD").style.format("{:.2f}"))

st.divider()

# Secci贸n de Correlaci贸n
st.subheader(" Correlaci贸n entre Acci贸n vs Volatilidad (VIX)")

# Selector de acci贸n
action = st.selectbox("Selecciona una acci贸n para analizar:", tickers)

# C谩lculo de correlaci贸n espec铆fico
col_action, col_graph = st.columns([1, 3])

with col_action:
    # Combinamos la acci贸n seleccionada y el VIX
    df_corr = data[[action, vix]].pct_change().dropna()
    correlation_value = df_corr.corr().iloc[0, 1]

    st.metric(label=f"Correlaci贸n {action} vs VIX", value=f"{correlation_value:.2f}")

    if correlation_value < -0.5:
        st.info(" Correlaci贸n negativa fuerte: La acci贸n tiende a subir cuando el miedo (VIX) baja.")
    elif correlation_value > 0.5:
        st.warning("锔 Correlaci贸n positiva: La acci贸n se mueve igual que la volatilidad.")

with col_graph:
    # Gr谩fico de dispersi贸n (Scatter Plot)
    fig_corr, ax = plt.subplots(figsize=(8, 4))
    sns.scatterplot(x=data[vix], y=data[action], ax=ax, color='blue', alpha=0.6)
    ax.set_title(f'Relaci贸n: {action} vs VIX')
    ax.set_xlabel('ndice de Volatilidad (^VIX)')
    ax.set_ylabel(f'Precio de {action}')
    ax.grid(True, alpha=0.3)
    st.pyplot(fig_corr)

st.divider()

# Secci贸n de Retornos Diarios
st.subheader(" Volatilidad de Retornos Diarios")
fig_ret, ax = plt.subplots(figsize=(12, 5))
returns.plot(ax=ax, alpha=0.7)
plt.title("Comparaci贸n de Retornos Diarios")
plt.ylabel("Retorno %")
plt.grid(True, alpha=0.3)
st.pyplot(fig_ret)